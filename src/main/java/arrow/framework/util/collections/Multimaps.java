/*
 * JBoss, Home of Professional Open Source Copyright 2010, Red Hat Middleware LLC, and individual contributors by the
 * @authors tag. See the copyright.txt in the distribution for a full listing of individual contributors. Licensed under
 * the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You
 * may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or
 * agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
package arrow.framework.util.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


/**
 * The Class Multimaps.
 */
public abstract class Multimaps {

    /**
     * The Class CustomSetMultimap.
     *
     * @param <K> the key type
     * @param <V> the value type
     */
    private static class CustomSetMultimap<K, V> extends AbstractSetMultimap<K, V> {

        /**
         * Instantiates a new custom set multimap.
         *
         * @param map the map
         */


        CustomSetMultimap(final Map<K, Collection<V>> map) {
            super(map);
        }

        /* (non-Javadoc)
         * @see arrow.framework.util.collections.AbstractSetMultimap#createCollection()
         */
        @Override
        protected Set<V> createCollection() {
            return new HashSet<V>();
        }

        /**
         * Write object.
         *
         * @param stream the stream
         * @throws IOException Signals that an I/O exception has occurred.
         * @serialData the factory and the backing map
         */
        private void writeObject(final ObjectOutputStream stream) throws IOException {
            stream.defaultWriteObject();
            stream.writeObject(this.backingMap());
        }


        /**
         * Read object.
         *
         * @param stream the stream
         * @throws IOException Signals that an I/O exception has occurred.
         * @throws ClassNotFoundException the class not found exception
         */
        @SuppressWarnings("unchecked")
        // reading data stored by writeObject
        private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {
            stream.defaultReadObject();
            final Map<K, Collection<V>> map = (Map<K, Collection<V>>) stream.readObject();
            this.setMap(map);
        }
    }

    /**
     * Creates a new {@code SetMultimap} that uses the provided map and factory. It can generate a multimap based on
     * arbitrary {@link Map} and {@link Set} classes.
     * <p/>
     * <p/>
     * The {@code factory}-generated and {@code map} classes determine the multimap iteration order. They also specify
     * the behavior of the {@code equals}, {@code hashCode}, and {@code toString} methods for the multimap and its
     * returned views. However, the multimap's {@code get} method returns instances of a different class than
     * {@code factory.get()} does.
     * <p/>
     * <p/>
     * The multimap is serializable if {@code map}, {@code factory}, the sets generated by {@code factory}, and the
     * multimap contents are all serializable.
     * <p/>
     * <p/>
     * The multimap is not threadsafe when any concurrent operations update the multimap, even if {@code map} and the
     * instances generated by {@code factory} are. Concurrent read operations will work correctly. To allow concurrent
     * update operations, wrap the multimap with a call to {@link #synchronizedSetMultimap}.
     * <p/>
     * <p/>
     * Call this method only when the simpler methods HashMultimap#create(), LinkedHashMultimap#create(),
     * TreeMultimap#create(), and TreeMultimap#create(Comparator, Comparator) won't suffice.
     * <p/>
     * <p/>
     * Note: the multimap assumes complete ownership over of {@code map} and the sets returned by {@code factory}. Those
     * objects should not be manually updated and they should not use soft, weak, or phantom references.
     *
     * @param <K> the key type
     * @param <V> the value type
     * @param map place to store the mapping from each key to its corresponding values
     * @return the sets the multimap
     * @throws IllegalArgumentException if {@code map} is not empty
     */
    public static <K, V> SetMultimap<K, V> newSetMultimap(final Map<K, Collection<V>> map) {
        return new CustomSetMultimap<K, V>(map);
    }
}
